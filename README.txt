Προγραμματισμός Συστήματος - Εργασία 3 - Mirroring System
Ονοματεπώνυμο: Κωνσταντίνος Κολυβάς
Α.Μ.: 1115201200066

1. Εισαγωγικά:
	1.1. Εντολή μεταγλώττισης & ενδεικτικές εντολές εκτέλεσης:
		Μεταγλώττιση:
			make cs/ms/mi/all (Default: all)
		Εκτέλεση:
			Mirror Server:
				mirror-serv -m output -w <workers> -p <port> (-s)
				content-serv -d relativ_or_absolute/path/to/dir/or/file -w <worker> -p <port>
				mirror-init -n <address> -p <port> -s <	<ContentServerAddress1>:<ContentServerPort1>:<Directory or filename1>:<Delay1>
	1.2. Οι επιλογές γραμμής εντολών είναι αυτές που υπάρχουν στην εκφώνηση της εργασίας με την πρόσθεση των εξής:
		1.2.1 Σε όλα τα προγράμματα έχει προστεθεί η επιλογή "--debug", οπότε και εκτυπώνονται επιπρόσθετα μηνύματα
		1.2.2 Στο πρόγραμμα mirror-serv υπάρχει η επιλογή "-s", η οποία επιτρέπει στο πρόγραμμα να αναζητήσει στην λίστα από τον content-server
				την οντότητα που έχει ζητήσει ο χρήστης
		1.2.3. Στο πρόγραμμα content-serv έχει προστεθεί η επιλογή "-w", η οποία δηλώνει τον αριθμό των threads που θα τρέχουν στο πρόγραμμα
				για να εξυπηρετούν τους mirror servers

2. Υλοποίηση:
	2.1. Λειτουργία content server:
		Κατά την εκκίνηση του, ο κάθε content server δημιουργεί N worker threads. Αυτά τα threads επικοινωνούν με το Master thread μόνο μέσω μια ουράς, 
		ο συγχρονισμός της οποίας ελέγχεται από έναν αριθμό από mutex (περισσότερες πληροφορίες βρίσκονται μέσα στα αρχεία κώδικα σε μορφή σχολίων).
		Το Master thread "ακούει" στο port που του έχει ανατεθεί για τυχόν αιτήματα, ενώ τα worker threads περιμένουν την εισαγωγή κάποιου στοιχείου στην ουρά.
		Όταν έρθει ένα αίτημα, το socket file descriptor του εισάγεται στην ουρά και επανέρχεται στην κατάσταση αναμονής αίτησης.
		Με την εισαγωγή κάποιου στοιχείου στην ουρά, κάποιο worker thread, το οποίο μέχρι εκείνη την στιγμή περίμενε, "ξυπνάει" και ικανοποιεί την αίτηση
		(βλ. 2.1 - Διαδικασία μεταφοράς αρχείων).
	
	2.2. Διαδικασία μεταφοράς αρχείων:
		2.2.1. Κάθε content server, κατά την εκκίνησή του, δημιουργεί N worker threads. Κάθε ένα από αυτά τα threads, στέλνει αίτημα LIST στο content server που του
			έχει ανατεθεί. Αφού πάρει τα αποτελέσματα του αιτήματος, ελέγχει για ταύτιση μέρους του μονοπατιού του αρχείου με το μονοπάτι που έχει ζητήσει ο χρήστης
			(η ταύτιση αυτή εξαρτάται από το flag -s. Για περισσότερες πληροφορίες για το πως λειτουργεί αυτό το flag, βλ. mirror-server/source/mirror_manager.cpp::mirror_manager.cpp)
			Αν υπάρξει τέτοια ταύτιση, τότε αυτό το αρχειο μαζί με το address, port και id στην λίστα υπό την μορφή:
				path/to/file:address:port:id
			Μόλις κάποιο worker thread "δει" κάποιο στοιχείο στην ουρά, το εξάγει από αυτή και στέλνει εντολή FETCH στο address:port μαζί με το ID 
			που έχει παρέξει το mirror manager. Τέλος, διαβάζει τα bytes του αρχείου από τον server και τα αποθηκεύει σε τοπικό κατάλογο.
			(Για περισσότερες πληροφορίες βλ. 2.2.3. Μεταφορά αρχείων)
		2.2.2. Μεταφορά ονομάτων αρχείων:
			Όταν κάποιο αίτημα FETCH φτάσει σε κάποιο content server, το αίτημα εισέρχεται σε μια ουρά το κάθε στοιχείο της 
			οποίας αναλαμβάνεται από ένα από τα νήματα που τρέχουν. Το νήμα αυτό κοιτάζει αναδρομικά στον φάκελο και υποφακέλους που έχουν ανατεθεί στον 
			content server και δημιουργεί μια λίστα ονομάτων αρχείων την οποία και αποστέλλει με τον εξής τρόπο:
			Βρίσκεται ο αριθμός επαναλήψεων που απαιτούνται για να αποσταλεί ολόκληρο το όνομα του αρχείο (μήκος αρχείου σε bytes / μέγεθος buffer
			(σταθερά ορισμένη στο αρχείο shared/include/constants.h)). Αποστέλεται στον client αυτός ο αριθμός και, στη συνέχεια, 
			και τα 2 προγράμματα μπαίνουν σε μια δομή επανάληψης μέχρι να ληφθεί όλο το όνομα του αρχείου. Μετά την αποστολή ολόκληρης της λίστας,
			η σύνδεση κλείνει και το νήμα περιμένει το επόμενο αίτημα.
		2.2.3. Μεταφορά αρχείων:
			Μόλις κάποιο νήμα του content server δεχθεί αίτημα FETCH, διαβάζει το delay από το hash table σύμφωνα με το ID, κάνει sleep για το συγκεκριμένο
			διάστημα και ξεκινάει την μεταφορά του αρχείου:
			Αρχικά ανοίγει το αρχείο (σε binary mode), βρίσκει το μέγεθός του και το στέλνει στον worker του mirror server. Στη συνέχεια, δημιουργεί έναν
			buffer συγκεκριμένου μήκους, και "σπάει" το αρχείο σε <μήκος αρχείου> / <μήκος buffer> κομμάτια. Κάνει τόσες επαναλήψεις όσες είναι τα κομμάτια
			και τα αποστέλει ένα προς ένα. Μετά την αποστολή όλων των κομματιών του αρχείου, η σύνδεση κλείνει και το νήμα περιμένει το επόμενο αίτημα.


	2.3. Χρήση Threads:
		Η λειτουργία έχει γραφτεί ιδιαίτερα λεπτομερώς σε μορφή σχολίων μέσα στα αρχεία κώδικα. 
		(mirror-server/source/mirror_server.cpp|worker.cpp|mirror_manager.cpp)
	

